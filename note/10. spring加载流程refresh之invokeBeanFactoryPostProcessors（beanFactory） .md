#### invokeBeanFactoryPostProcessors
```
/**
 * 在上下文中调用注册为bean的工厂处理器
 */
invokeBeanFactoryPostProcessors(beanFactory);
```

```
protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {

		/**
		 * getBeanFactoryPostProcessors获取自定义的beanFactoryPostProcessor
		 * 何为自定义？
		 * 不通过注解形式扫描获取
		 * 而是通过手动context.addBeanFactoryPostProcessor(beanFactoryPostProcessor)完成自定义
		 *
		 * getBeanFactoryPostProcessors默认是个空的List
		 */
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

		// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
		// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
		/**
		 * 如果发现loadTimeWeaver的Bean
		 * 添加BeanPostProcessor->LoadTimeWeaverAwareProcessor
		 */
		if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}
	}
```

#### getBeanFactoryPostProcessors()
这里的getBeanFactoryPostProcessors()就是单纯的通过addBeanFactoryPostProcessor方法添加的BFPP

打个断点演示一下

空的，因为没有通过addBeanFactoryPostProcessor方法添加BFPP，需要的话可以在main函数中执行这个方法，这里就不演示了

#### PostProcessorRegistrationDelegate类
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法
内容太多，先贴出一半代码
```
if (beanFactory instanceof BeanDefinitionRegistry) {
			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;

			/**
			 * 常规的BeanFactoryPostProcessor
			 */
			List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();

			/**
			 * 实现自定义注册bean定义逻辑的BeanFactoryPostProcessor
			 */
			List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();

			/**
			 * beanFactoryPostProcessors默认为空
			 * 除非通过context.addBeanFactoryPostProcessor(beanFactoryPostProcessor)添加
			 */
			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
					BeanDefinitionRegistryPostProcessor registryProcessor =
							(BeanDefinitionRegistryPostProcessor) postProcessor;
					registryProcessor.postProcessBeanDefinitionRegistry(registry);
					registryProcessors.add(registryProcessor);
				}
				else {
					regularPostProcessors.add(postProcessor);
				}
			}

			// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the bean factory post-processors apply to them!
			// Separate between BeanDefinitionRegistryPostProcessors that implement
			// PriorityOrdered, Ordered, and the rest.

			/**
			 * spring自己内部的BeanFactoryPostProcessor
			 * 不是通过context.addBeanFactoryPostProcessor(beanFactoryPostProcessor)添加的
			 */
			List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList<>();

			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
			String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			/**
			 * 这个地方得到一个BeanFactoryPostProcessor,因为是spring默认在最开始自己注册的
			 * 为什么要在最开始注册这个bean？
			 * 因为spring工厂需要去解析、扫描等功能
			 * 而这些功能都是需要在spring工厂初始化完成之前去执行
			 * 要么在工厂最开始的时候、要么在工程初始化之中，反正不能在之后
			 *
			 * 所以这里spring在一开始的时候就注册了一个BeanFactoryPostProcessor,用来插手springFactory的实例化过程
			 * 此处断点可知这个类叫做：ConfigurationAnnotationProcessor
			 */
			for (String ppName : postProcessorNames) {
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			// 排序不重要，况且这里currentRegistryProcessors只有一条数据
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			// 合并List
			registryProcessors.addAll(currentRegistryProcessors);
			/**
			 * 这个方法最重要
			 * 开始循环调用BeanDefinitionRegistryPostProcessor
			 *
			 * 其中有一个spring内部的BeanDefinitionRegistryPostProcessors——>ConfigurationClassPostProcessor
			 * 处理@Configuration/@Component等注解，扫描、注册包下的类
			 * 处理@Import/@ImportResource/@Bean等...
			 */
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			/**
			 * 清除临时变量，后面还要用这个变量
			 */
			currentRegistryProcessors.clear();

			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
			sortPostProcessors(currentRegistryProcessors, beanFactory);
			registryProcessors.addAll(currentRegistryProcessors);
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			currentRegistryProcessors.clear();

			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
			boolean reiterate = true;
			while (reiterate) {
				reiterate = false;
				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
				for (String ppName : postProcessorNames) {
					if (!processedBeans.contains(ppName)) {
						currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
						processedBeans.add(ppName);
						reiterate = true;
					}
				}
				sortPostProcessors(currentRegistryProcessors, beanFactory);
				registryProcessors.addAll(currentRegistryProcessors);
				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
				currentRegistryProcessors.clear();
			}

			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
			/**
			 * 前面执行的是BeanFactoryPostProcessor的子类BeanDefinitionRegistryPostProcessor的回调
			 * 现在执行BeanFactoryPostProcessor的回调
			 */
			invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
		}
```
首先有个判断if (beanFactory instanceof BeanDefinitionRegistry)，beanFactory 就是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry

值得关注的一行代码
```
String[] postProcessorNames =
					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
```
从beanFactory中获得所有类型为BeanDefinitionRegistryPostProcessor的beanDefinition的beanName

spring一开始就注册的内部bean有一个就实现了BeanDefinitionRegistryPostProcessor，就是ConfigurationClassPostProcessor，同时这也是一个BFPP。注册内部bean可以看这篇spring加载流程之AnnotatedBeanDefinitionReader
然后通过beanName获取beanDefinition并被添加进currentRegistryProcessors中
```
currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
```
最后开始执行BFPP
```
invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
```
invokeBeanDefinitionRegistryPostProcessors
开始循环执行BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法
```
private static void invokeBeanDefinitionRegistryPostProcessors(
		Collection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry) {

		for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
			/**
			 * 简单点
			 * 这里默认其实只有一个BeanDefinitionRegistryPostProcessor——>就是ConfigurationClassPostProcessor
			 * 所以调用ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(registry)
			 */
			postProcessor.postProcessBeanDefinitionRegistry(registry);
		}
	}
```
