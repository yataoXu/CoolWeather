
```
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);

```

```
public AnnotationConfigApplicationContext(Class<?>... annotatedClasses) {
		/**
		 * 这里由于他有父类，所以会先调用父类的构造方法:
		 * 看源码得知初始化了DefaultListableBeanFactory
		 *
		 * 然后才调用自己的构造方法:
		 * 1.创建一个读取注解的Bean定义读取器
		 * 	将bean读取完后，会调用DefaultListableBeanFactory注册这个bean
		 * 2.
		 */
		this();
		register(annotatedClasses);
		refresh();
	}
```

#### 上下文的register(annotatedClasses)方法
看传参可知，可以同时注册多个calss，以逗号隔开
```
public void register(Class<?>... annotatedClasses) {
		Assert.notEmpty(annotatedClasses, "At least one annotated class must be specified");
		this.reader.register(annotatedClasses);
	}
```
`reader`就是默认构造函数初始化的`AnnotationBeanDefinitionReader`

#### AnnotatedBeanDefinitionReader
```
public void register (Class<?>... annotatedClasses) {
		for (Class<?> annotatedClass : annotatedClasses) {
			registerBean(annotatedClass);
		}
	}
	
public void registerBean(Class<?> annotatedClass) {
		doRegisterBean(annotatedClass, null, null, null);
	}
	
void doRegisterBean(Class<T> annotatedClass, @Nullable Supplier<T> instanceSupplier, @Nullable String name,
			@Nullable Class<? extends Annotation>[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {

		AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);

		/**
		 * 判断这个类是否需要跳过解析
		 */
		if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
			return;
		}

		abd.setInstanceSupplier(instanceSupplier);

		/**
		 * 得到类的作用域，默认为Singleton
		 */
		ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
		/**
		 * 将类的作用域添加到数据结构中
		 */
		abd.setScope(scopeMetadata.getScopeName());

		String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));

		/**
		 * 处理类当中的通用注解
		 * 分析源码可以知道他主要处理
		 * Lazy DependOn Primary Role等注解
		 * 处理完后 processCommonDefinitionAnnotations 依然是把他添加到数据结构当中去
		 */
		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);

		/**
		 * 如果在向容器注册注解bean定义时，使用了额外的限定符注解
		 * 依次判断了注解当中是否包含了Primary、Lazy、qualifier
		 */
		if (qualifiers != null) {
			for (Class<? extends Annotation> qualifier : qualifiers) {
				if (Primary.class == qualifier) {
					abd.setPrimary(true);
				}
				else if (Lazy.class == qualifier) {
					abd.setLazyInit(true);
				}
				else {
					abd.addQualifier(new AutowireCandidateQualifier(qualifier));
				}
			}
		}

		/**
		 * 自定义注解
		 */
		for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
			customizer.customize(abd);
		}

		/**
		 * 这个BeanDefinitionHolder也是一个数据结构
		 * 存放BeanDefinition
		 */
		BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);

		/**
		 * ScopedProxyMode 这个知识点比较复杂  需要结合web理解
		 */
		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);

		/**
		 * 把上述这个数据结构注册给registry
		 * registry就是AnnotationConfigApplicationContext
		 *
		 * */
		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
	}
```
主要看最后一个方法，内容有点多，直接贴上了注释

执行refresh()之前
到这里，spring注册了7个beanDefinition，其中6个内部bean，一个自定义的配置bean


![](https://mmbiz.qpic.cn/mmbiz_png/vb4xFWPs1FgGZiaKEwof3qiciat3BXXgiawqRLic97Mwrw9bzYEv6JbaBo5GEhaibbpX88KsXJhgia2MibJs8f6azTwEkg/0?wx_fmt=png)
